# 前端重复代码分析报告

## 概述

本报告分析了前端代码中的重复组件和页面模式，识别可以提取为公共组件或 Hook 的部分。

---

## 一、列表组件重复模式

### 1.1 分页组件重复 ⚠️ **高优先级**

**位置**: 
- `features/grading/components/grading-list.tsx` (115-140行)
- `features/spot-checks/components/spot-check-list.tsx` (148-173行)

**问题**: 两个列表组件中有几乎完全相同的分页代码：

```tsx
{/* 分页 */}
<div className="flex items-center justify-between mt-4 pt-4 border-t border-[#E5E7EB]">
  <span className="text-sm text-[#6B7280]">
    共 {data.count || 0} 条记录  // 仅文本不同
  </span>
  <div className="flex gap-2">
    <Button
      variant="outline"
      size="sm"
      disabled={page === 1}
      onClick={() => setPage(page - 1)}
      className="shadow-none border-4 border-[#E5E7EB]"
    >
      上一页
    </Button>
    <Button
      variant="outline"
      size="sm"
      disabled={!data.next}
      onClick={() => setPage(page + 1)}
      className="shadow-none border-4 border-[#E5E7EB]"
    >
      下一页
    </Button>
  </div>
</div>
```

**注意**: `features/test-center/components/quiz-tab.tsx` 和 `features/test-center/components/question-tab.tsx` 中也有相似但略有不同的分页实现。

**建议**: 
- 创建一个通用的 `SimplePagination` 组件
- 或者使用已有的 `Pagination` 组件（`features/knowledge` 中已在使用）

**示例实现**:
```tsx
// components/ui/simple-pagination.tsx
interface SimplePaginationProps {
  currentPage: number;
  hasNext: boolean;
  totalCount: number;
  countLabel: string; // 如 "条记录"、"份待评分"
  onPageChange: (page: number) => void;
}

export const SimplePagination: React.FC<SimplePaginationProps> = ({
  currentPage,
  hasNext,
  totalCount,
  countLabel,
  onPageChange,
}) => {
  return (
    <div className="flex items-center justify-between mt-4 pt-4 border-t border-[#E5E7EB]">
      <span className="text-sm text-[#6B7280]">
        共 {totalCount || 0} {countLabel}
      </span>
      <div className="flex gap-2">
        <Button
          variant="outline"
          size="sm"
          disabled={currentPage === 1}
          onClick={() => onPageChange(currentPage - 1)}
          className="shadow-none border-4 border-[#E5E7EB]"
        >
          上一页
        </Button>
        <Button
          variant="outline"
          size="sm"
          disabled={!hasNext}
          onClick={() => onPageChange(currentPage + 1)}
          className="shadow-none border-4 border-[#E5E7EB]"
        >
          下一页
        </Button>
      </div>
    </div>
  );
};
```

---

### 1.2 列表空状态重复 🟡 **中优先级**

**位置**: 
- `features/grading/components/grading-list.tsx` (143-146行)
- `features/spot-checks/components/spot-check-list.tsx` (176-186行)

**问题**: 空状态实现略有不同，但可以统一：

```tsx
// grading-list.tsx
<div className="flex flex-col items-center justify-center py-12 text-[#6B7280]">
  <FileText className="w-12 h-12 text-[#9CA3AF] mb-4" />
  <span className="text-base">暂无待评分答卷</span>
</div>

// spot-check-list.tsx
<div className="flex flex-col items-center justify-center py-12 text-[#6B7280]">
  <Search className="w-12 h-12 text-[#9CA3AF] mb-4" />
  <span className="text-base mb-4">暂无抽查记录</span>
  <Button onClick={...}>发起第一次抽查</Button>  // 额外有操作按钮
</div>
```

**当前状态**: ✅ **部分良好** - `features/knowledge` 中已经使用了统一的 `EmptyState` 组件

**建议**: 
- 统一使用 `components/ui/empty-state.tsx` 组件
- 对于需要操作按钮的空状态，可以通过 `action` prop 支持

---

## 二、对话框组件重复模式

### 2.1 确认对话框模式重复 ⚠️ **高优先级**

**位置**: 多个组件中都有确认对话框，实现略有不同：

- `features/knowledge/components/knowledge-detail.tsx` (492-512行)
- `features/tasks/components/task-card.tsx` (276-292行, 295-312行)
- `features/tasks/components/task-management.tsx` (401-429行)
- `features/users/components/user-list.tsx` (395-427行)
- `features/knowledge/components/admin-knowledge-list.tsx` (264-288行)
- `features/submissions/components/quiz-player.tsx` (398-430行)

**问题**: 确认对话框的结构非常相似，但每次都重新实现：

```tsx
// 常见的确认对话框模式
<Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
  <DialogContent className="rounded-lg max-w-md p-10 border-0 bg-white shadow-none">
    <DialogHeader>
      <div className="w-20 h-20 bg-[...] ..."> {/* 图标 */}
        <Icon />
      </div>
      <DialogTitle>确认标题</DialogTitle>
      <DialogDescription>确认描述</DialogDescription>
    </DialogHeader>
    <DialogFooter>
      <Button variant="outline/ghost" onClick={onCancel}>取消</Button>
      <Button onClick={onConfirm} disabled={isPending}>
        {isPending ? "处理中..." : "确认"}
      </Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

**建议**: 
创建通用的 `ConfirmDialog` 组件

**示例实现**:
```tsx
// components/ui/confirm-dialog.tsx
interface ConfirmDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  title: string;
  description: string;
  icon?: React.ReactNode;
  iconBgColor?: string; // 如 "bg-[#FEE2E2]" 
  iconColor?: string; // 如 "text-[#DC2626]"
  confirmText?: string;
  cancelText?: string;
  confirmVariant?: 'default' | 'destructive';
  onConfirm: () => void | Promise<void>;
  isConfirming?: boolean;
}

export const ConfirmDialog: React.FC<ConfirmDialogProps> = ({
  open,
  onOpenChange,
  title,
  description,
  icon,
  iconBgColor = 'bg-[#DBEAFE]',
  iconColor = 'text-[#3B82F6]',
  confirmText = '确认',
  cancelText = '取消',
  confirmVariant = 'default',
  onConfirm,
  isConfirming = false,
}) => {
  const handleConfirm = async () => {
    await onConfirm();
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="rounded-lg max-w-md p-10 border-0 bg-white shadow-none">
        <DialogHeader>
          {icon && (
            <div className={`w-20 h-20 ${iconBgColor} ${iconColor} rounded-lg flex items-center justify-center mb-8 mx-auto`}>
              {icon}
            </div>
          )}
          <DialogTitle className="text-2xl font-bold text-[#111827] mb-2 text-center">
            {title}
          </DialogTitle>
          <DialogDescription className="text-[#6B7280] font-medium text-center leading-relaxed">
            {description}
          </DialogDescription>
        </DialogHeader>
        <DialogFooter className="mt-10 gap-4 sm:flex-row">
          <Button
            variant="ghost"
            onClick={() => onOpenChange(false)}
            className="flex-1 rounded-md h-14 font-semibold text-[#6B7280] hover:bg-[#F3F4F6] shadow-none"
          >
            {cancelText}
          </Button>
          <Button
            onClick={handleConfirm}
            disabled={isConfirming}
            variant={confirmVariant === 'destructive' ? 'destructive' : 'default'}
            className={`flex-1 text-white rounded-md h-14 font-semibold shadow-none hover:scale-105 transition-all duration-200 ${
              confirmVariant === 'destructive' 
                ? 'bg-[#DC2626] hover:bg-[#B91C1C]' 
                : 'bg-[#111827] hover:bg-[#374151]'
            }`}
          >
            {isConfirming ? '处理中...' : confirmText}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};
```

**优先级**: 🔴 **高** - 可以显著减少重复代码，提高一致性

---

## 三、表单组件重复模式

### 3.1 表单验证模式重复 🟡 **中优先级**

**位置**: 多个表单组件都有相似的验证逻辑：

- `features/spot-checks/components/spot-check-form.tsx` (40-48行)
- `features/users/components/user-form.tsx` (116-124行)
- `features/knowledge/components/knowledge-form.tsx` (159-182行)
- `features/questions/components/question-form.tsx` (189-210行)

**问题**: 验证函数的结构相似：

```tsx
const validate = () => {
  const newErrors: Record<string, string> = {};
  if (!field1) newErrors.field1 = '错误消息';
  if (!field2) newErrors.field2 = '错误消息';
  setErrors(newErrors);
  return Object.keys(newErrors).length === 0;
};
```

**当前状态**: ✅ **可接受** - 这种重复是合理的，因为：
- 每个表单的验证规则不同
- 验证逻辑通常与业务逻辑紧密相关
- 过度抽象可能降低代码可读性

**建议**: 保持现状，不建议过度抽象。如果未来需要更复杂的验证，可以考虑使用 `react-hook-form` 或 `zod`。

---

### 3.2 表单提交模式重复 ✅ **可接受**

**位置**: 所有表单组件

**问题**: 表单提交的模式相似（验证 → 调用 API → 成功处理 → 错误处理）

**当前状态**: ✅ **可接受** - 这是标准的表单提交流程，重复是合理的

---

## 四、其他重复模式

### 4.1 用户头像显示重复 ✅ **已通过组件复用**

**位置**: 多个列表组件中显示用户头像

**当前状态**: ✅ **良好** - 代码中使用了统一的 Avatar 组件模式，虽然实现略有不同，但都是简单的头像显示，重复是合理的

---

### 4.2 状态 Badge 显示 ✅ **已通过组件复用**

**位置**: 多个列表组件中显示状态

**当前状态**: ✅ **良好** - 使用了统一的 `StatusBadge` 组件

---

## 五、总结与建议

### 5.1 需要改进的重复代码

1. **🔴 高优先级**:
   - **分页组件重复** (1.1) - 创建 `SimplePagination` 组件
   - **确认对话框重复** (2.1) - 创建 `ConfirmDialog` 组件

2. **🟡 中优先级**:
   - **列表空状态** (1.2) - 统一使用 `EmptyState` 组件（部分已使用）

### 5.2 可接受的重复代码

以下重复是合理的，不建议过度抽象：
- **表单验证模式** (3.1) - 每个表单的验证规则不同
- **表单提交模式** (3.2) - 标准流程，重复合理
- **用户头像显示** (4.1) - 简单实现，重复可接受
- **状态 Badge** (4.2) - 已通过组件复用

### 5.3 改进优先级

1. **创建 ConfirmDialog 组件**（优先级最高）
   - 影响范围最广（6+ 个组件）
   - 代码重复最多
   - 可以显著提高一致性

2. **创建 SimplePagination 组件**（高优先级）
   - 影响 2-3 个组件
   - 代码重复明显

3. **统一使用 EmptyState 组件**（中优先级）
   - 部分组件已使用，需要迁移剩余的

---

## 六、代码质量评估

总体而言，前端代码的重复控制得**较好**：

✅ **优点**:
- 已通过 UI 组件库（如 `StatusBadge`, `EmptyState`, `Pagination`）复用通用组件
- 表单验证和提交的模式虽然重复，但这是合理的业务模式重复
- 大部分重复是合理的实现重复，而非可以提取的通用逻辑

⚠️ **改进空间**:
- 确认对话框可以进一步抽象（影响范围广）
- 分页组件可以统一（2-3 处重复）

**总体评分**: 7.5/10 - 代码质量良好，有明确的改进方向
